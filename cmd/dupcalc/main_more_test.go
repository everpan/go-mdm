package main

import (
	"io"
	"os"
	"path/filepath"
	"testing"
)

// This test exercises additional branches in main: exclude directories,
// block comments across lines, and the path where the window size is larger
// than the number of lines in a file.
func TestMain_CommentsExcludeAndSmallWindow(t *testing.T) {
	dir := t.TempDir()
	// Excluded directory with a go file that should be skipped
	if err := os.Mkdir(filepath.Join(dir, "vendor"), 0o755); err != nil {
		t.Fatalf("mkdir vendor: %v", err)
	}
	_ = os.WriteFile(filepath.Join(dir, "vendor", "x.go"), []byte("package v\nfunc X(){}\n"), 0o644)

	// File with multi-line block comment to exercise inBlockComment logic
	code := `package p
/* block start
still comment */
// line comment
func C() {
	println(1) /* mid */ println(2)
}
`
	if err := os.WriteFile(filepath.Join(dir, "c.go"), []byte(code), 0o644); err != nil {
		t.Fatalf("write c.go: %v", err)
	}

	// Generated files to exercise skip branches
	_ = os.WriteFile(filepath.Join(dir, "zz_gen.go"), []byte("package p\n// generated file\n"), 0o644)
	_ = os.WriteFile(filepath.Join(dir, "generated_something.go"), []byte("package p\n// generated by tool\n"), 0o644)

	// Another file that will be too short for the selected window size
	short := `package p
func D() { println(0) }
`
	if err := os.WriteFile(filepath.Join(dir, "d.go"), []byte(short), 0o644); err != nil {
		t.Fatalf("write d.go: %v", err)
	}

	oldArgs := os.Args
	defer func() { os.Args = oldArgs }()
	// Use window=2 to both create duplicates and keep short file under the window size
	os.Args = []string{"dupcalc", "-root", dir, "-w", "2", "-exclude", "vendor"}

	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w
	defer func() { os.Stdout = oldStdout }()

	main()
	_ = w.Close()
	_, _ = io.ReadAll(r) // we only care that it runs without error and covers code paths
}
